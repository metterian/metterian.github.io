---
layout: post
title: "🐍 [Python] 객체(Object) 이해하기"
author: "metterian"
tags: Python
---
## 들어가며

### 클래스와 객체의 개념

#### 1. Class 라는 것은 새로운 데이터 타입이다

사용자가 정의한 데이터 타입으로 변수를 선헌 후, new 연산자, 생성자를 이용해 메모리를 만든다. (메모리의 생성: 데이터 타입에 해당하는 만큼의 메모리를 확보하는 일)

#### 2. 새로운 클래스를 하나 만드는 것

새로운 클래스를 하나 만드는 것은 다음과 같은 말로 대치가 가능하다.

1. 새로운 데이터 타입을 만드는 것

2. 이 타입으로 변수를 선언/활용 할 수 있다. 

   이때 클래스를 이용한 변수를 **객체** 또는 객체 변수라고 한다. (단, 객체, 객체 변수는 기본 데이터 변수와 다르다. <u>객체 변수 선언 후 메모리를 생성해줘야 완전한 객체가 된다.</u>)

```java
Top t = new Top();
```

<br>

### 메모리 생성

#### 자바 언어에서는 주소를 바로 주지 않는다.

클래스로 만든 데이터 타입으로 변수와 메모리를 생성 햇을 때 주소를 찾아보기는 힘들다. **자바에서는 객체의 주소 대신 참조값이라는 것을 할당 받게 된다.** 그렇기 때문에 자바에서는 객체 변수(Reference Variable)를 참조 변수라고 말한다.

```java
// 1. 클래스 선언
public class Sun{
  public int distance;
  public int data;
}

// 2. 객체 변수 선언: 메모리 생성전이므로 초기화
Sun s1 = null;
Sun s2 = null;

// 3. 객체 변수에 대한 메모리 생성
s1 = new Sun();
s2 = new Sun();
```

위와 같이 메모리가 생성되면 내부의 인덱스 테이블에서 주소 매핑 후 참조값을 만들고 참조값은 참조 변수 `s1`, `s2` 에 할당 됩니다. 



### 참조변수의 특징

- 참조값(Reference Value):  참조값이란 객체의 메모리를 생성 했을 때, 메모리와 연결된 유일한 숫자값을 말한다. 이 숫자값을 참조 변수가 받으며, 이 참조값을 가지고 있으면 객체를 핸들링 할 수 있다. 참조값으로 작업하면 내부에서 참조값에 연결된 메모리로 작업하는 것과 같은 효과가 있다.



### **참조 횟수 계산 방식 **(reference counting)

> **참조 횟수 계산 방식**(reference counting)은 메모리를 제어하는 방법 중 하나로, [쓰레기 수집](https://ko.wikipedia.org/wiki/쓰레기_수집_(컴퓨터_과학))의 한 방식이다. 구성 방식은 단순하다. 어떤 한 동적 단위(객체, Object)가 참조값을 가지고 이 단위 객체가 참조(참조 복사)되면 참조값을 늘리고 참조한 다음 더이상 사용하지 않게 되면 참조값을 줄이면 된다. 보통 참조값이 0이 되면 더이상 유효한 단위 객체로 보지 않아 메모리에서 제거한다.
>
> 출처: [참조 횟수 계산 방식 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%EC%B0%B8%EC%A1%B0_%ED%9A%9F%EC%88%98_%EA%B3%84%EC%82%B0_%EB%B0%A9%EC%8B%9D)

사전적 설명 보다 쉽게 설명 하면 가비지 콜렉션(Garbage Collection)이란 [메모리](https://namu.wiki/w/메모리) 관리 방법 중 하나로, [프로그래머](https://namu.wiki/w/프로그래머)가 동적으로 할당한 메모리 영역 중 더 이상 쓰이지 않는 영역을 자동으로 찾아내어 해제하는 기능이다. 

참조 횟수 계산 방법은 이러한 가비지 콜렉션의 한 가지 방식으로 어떤 객체가 참조값을 가지며, 객체가 참조되면 참조값을 늘리고, 더 이상 사용하지 않으면 참조값을 줄입니다. 보통 참조값이 0이 되면 더 이상 유효한 객체로 간주하지 않아 메모리에서 제거하게 됩니다. 



### Call by reference vs. Call by Value

파이썬에서는 객체의 종류에 다라서 Call by reference 또는 Call by Value가 결정 됩니다. `str`, `int` 과 같은 불변 객체 일 경우 call by value에 의해서 관리 되고, `list', ``dict` 과 같은 변이 객체에서는 object referece로 관리 됩니다. 

<br>

<br>



## 파이썬의 객체 구조

### 파이썬은 정적이 아닌 동적 타입이다.

이것은 프로그램 실행 시, 인터프리터는 정의된 변수의 유형을 알고 있지 않다는것을 의미합니다. C변수와 파이썬 변수의 차이는 아래 그림으로 요약 됩니다. C 언어 변수의 경우, 컴파일러는 단지 그 정의만으로도 변수의 유형을 알고 있습니다. 

하지만, 파이썬에서는 변수를 선언 할 때 어떠한 변수 타입인지 명시하지 않고 또한 변수에는 다양한 자료형을 할당 할 수 있습니다. 뒤에서 설명하겠지만 이러한 동적 타이핑이 가능한 이유는 파이썬에서의 변수 할당을 객체를 통해 이루어지기 때문입니다. (변수에 값을 할당한다는 표현 보다는 객체에 변수 이름을 라벨링(Labeling)한다는 표현이 더 이해하기 쉬운 표현 입니다.  )



<img src="https://miro.medium.com/max/700/1*vrwoH-6VhOUJ2bcGwbGWZw.png" alt="1*vrwoH-6VhOUJ2bcGwbGWZw" style="zoom: 67%;" />

C 컴파일러는 시작할 때부터 a와 b는 정수형이라는 것을 알고 있지만, 단순한 어떤것도 할 수 없습니다. 정수형을 아는것으로는 메모리 상의 단순한 값에 두 개의 정수를 더하고, 이를 다른 정수로 반환하는 루틴을 호출할 수 있습니다. 개략적인 도식으로 나타내면 이벤트의 순서는 다음과 같습니다.

#### C 덧셈

C에서 다음을 작성하는 경우:

```c
/* C code */ 
int a = 1; 
int b = 2; 
int c = a + b;
```

<br>

**계산과정**:

1. <int> 1을 a에 할당
2. <int> 2을 b에 할당
3. binary_add<int, int>(a,b) 호출
4. 결과를 c에 할당



<br>

#### Python 덧셈

파이썬에서의 같은 역할의 코드는 아래와 같습니다.

```python
# python code
a = 1
b = 2
c = a + b
```

<br>

**계산과정**:

1. `a` 에 1을 할당
   1. `a` -> `PyObject_HEAD` -> typecode 정수 설정
   2. `a` -> `val=1` 설정
2. `b`에 2를 할당
   1. `b`-> `PyObject_HEAD` -> typecode 정수 설정
   2. `b` -> `val=2` 설정
3. binary_add(a,b) 호출
   1.  `a`->`PyObject_HEAD` 에서 typecode 찾기
   2.  `a`는 정수형; 값 `a->val`
   3. `b`->PyObject_HEAD 에서 typecode 찾기
   4. `b`는 정수형; 값 `b->val`
   5. `binary_add<int, int>(a->val, b->val)` 호출
   6. 정수형 결과값 result
4. 파이썬 개체 `c` 생성
   1. `c`->`PyObject_HEAD`->typecode 정수 설정
   2. `c`->`val`에 result 설정



동적 타이핑은 정적 타이핑에 비해 더 많은 단계를 포함합니다. 이러한 이유 때문에 파이썬이 C보다 느린 이유이기도 합니다.